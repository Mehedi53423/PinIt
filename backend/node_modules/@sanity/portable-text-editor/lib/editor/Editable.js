"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PortableTextEditable = void 0;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _slate = require("slate");

var _isHotkey = _interopRequireDefault(require("is-hotkey"));

var _blockTools = require("@sanity/block-tools");

var _react = _interopRequireWildcard(require("react"));

var _slateReact = require("@sanity/slate-react");

var _values = require("../utils/values");

var _copyPaste = require("../utils/copyPaste");

var _selection2 = require("../utils/selection");

var _ranges = require("../utils/ranges");

var _debug = require("../utils/debug");

var _weakMaps = require("../utils/weakMaps");

var _Leaf = require("./Leaf");

var _Element = require("./Element");

var _usePortableTextEditor = require("./hooks/usePortableTextEditor");

var _usePortableTextEditorValue = require("./hooks/usePortableTextEditorValue");

var _PortableTextEditor = require("./PortableTextEditor");

var _plugins = require("./plugins");

var _useForwardedRef = require("./hooks/useForwardedRef");

var _excluded = ["hotkeys", "onBeforeInput", "onPaste", "onCopy", "placeholderText", "renderAnnotation", "renderBlock", "renderChild", "renderDecorator", "selection", "scrollSelectionIntoView", "spellCheck"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var debug = (0, _debug.debugWithName)('component:Editable'); // Weakmap for testing if we need to update the state value from a new value coming in from props

var VALUE_TO_SLATE_VALUE = new WeakMap();

var NOOP = () => {// Nope
};

var SELECT_TOP_DOCUMENT = {
  anchor: {
    path: [0, 0],
    offset: 0
  },
  focus: {
    path: [0, 0],
    offset: 0
  }
};
var PortableTextEditable = /*#__PURE__*/(0, _react.forwardRef)(function PortableTextEditable(props, forwardedRef) {
  var hotkeys = props.hotkeys,
      onBeforeInput = props.onBeforeInput,
      onPaste = props.onPaste,
      onCopy = props.onCopy,
      placeholderText = props.placeholderText,
      renderAnnotation = props.renderAnnotation,
      renderBlock = props.renderBlock,
      renderChild = props.renderChild,
      renderDecorator = props.renderDecorator,
      propsSelection = props.selection,
      scrollSelectionIntoView = props.scrollSelectionIntoView,
      spellCheck = props.spellCheck,
      restProps = _objectWithoutProperties(props, _excluded);

  var portableTextEditor = (0, _usePortableTextEditor.usePortableTextEditor)();
  var value = (0, _usePortableTextEditorValue.usePortableTextEditorValue)();
  var ref = (0, _useForwardedRef.useForwardedRef)(forwardedRef);
  var change$ = portableTextEditor.change$,
      isThrottling = portableTextEditor.isThrottling,
      keyGenerator = portableTextEditor.keyGenerator,
      portableTextFeatures = portableTextEditor.portableTextFeatures,
      readOnly = portableTextEditor.readOnly;
  var placeHolderBlock = (0, _react.useMemo)(() => ({
    _type: portableTextFeatures.types.block.name,
    _key: keyGenerator(),
    style: 'normal',
    markDefs: [],
    children: [{
      _type: 'span',
      _key: keyGenerator(),
      text: '',
      marks: []
    }]
  }), [portableTextFeatures.types.block.name, keyGenerator]); // React/UI-spesific plugins

  var withInsertData = (0, _react.useMemo)(() => (0, _plugins.createWithInsertData)(change$, portableTextFeatures, keyGenerator), [change$, keyGenerator, portableTextFeatures]);
  var withHotKeys = (0, _react.useMemo)(() => (0, _plugins.createWithHotkeys)(portableTextFeatures, keyGenerator, portableTextEditor, hotkeys), [hotkeys, keyGenerator, portableTextEditor, portableTextFeatures]); // Create the PortableTextEditor API

  var withEditableAPI = (0, _react.useMemo)(() => (0, _plugins.createWithEditableAPI)(portableTextEditor, portableTextFeatures, keyGenerator), [keyGenerator, portableTextEditor, portableTextFeatures]); // Update the Slate instance's plugins which are dependent on props for Editable

  (0, _react.useMemo)(() => withHotKeys(withInsertData(withEditableAPI((0, _slateReact.withReact)(portableTextEditor.slateInstance)))), [portableTextEditor.slateInstance, withEditableAPI, withHotKeys, withInsertData]); // Track editor value

  var _useState = (0, _react.useState)( // Default value
  (0, _values.toSlateValue)(getValueOrIntitialValue(value, [placeHolderBlock]), portableTextFeatures.types.block.name, _weakMaps.KEY_TO_SLATE_ELEMENT.get(portableTextEditor.slateInstance))),
      _useState2 = _slicedToArray(_useState, 2),
      stateValue = _useState2[0],
      setStateValue = _useState2[1];

  var stateValueRef = (0, _react.useRef)(stateValue); // Track selection state

  var _useState3 = (0, _react.useState)(portableTextEditor.slateInstance.selection),
      _useState4 = _slicedToArray(_useState3, 2),
      selection = _useState4[0],
      setSelection = _useState4[1];

  var selectionRef = (0, _react.useRef)(selection);

  var _useState5 = (0, _react.useState)(false),
      _useState6 = _slicedToArray(_useState5, 2),
      isSelecting = _useState6[0],
      setIsSelecting = _useState6[1];

  var renderElement = (0, _react.useCallback)(eProps => {
    return /*#__PURE__*/_react.default.createElement(_Element.Element, _extends({}, eProps, {
      keyGenerator: keyGenerator,
      portableTextFeatures: portableTextFeatures,
      readOnly: readOnly,
      renderBlock: renderBlock,
      renderChild: renderChild
    }));
  }, [keyGenerator, portableTextFeatures, readOnly, renderBlock, renderChild]);
  var renderLeaf = (0, _react.useCallback)(lProps => {
    return /*#__PURE__*/_react.default.createElement(_Leaf.Leaf, _extends({}, lProps, {
      keyGenerator: keyGenerator,
      portableTextFeatures: portableTextFeatures,
      renderAnnotation: renderAnnotation,
      renderChild: renderChild,
      renderDecorator: renderDecorator,
      readOnly: readOnly
    }));
  }, [portableTextFeatures, keyGenerator, renderAnnotation, renderChild, renderDecorator, readOnly]);
  var handleChange = (0, _react.useCallback)(val => {
    var nextSelection = portableTextEditor.slateInstance.selection;

    if (val !== stateValueRef.current) {
      setStateValue(val);
      stateValueRef.current = val;
    }

    if (nextSelection !== selectionRef.current) {
      setSelection(nextSelection);
      selectionRef.current = nextSelection;
    }
  }, [portableTextEditor]);
  (0, _react.useEffect)(() => {
    _weakMaps.KEY_TO_SLATE_ELEMENT.set(portableTextEditor.slateInstance, {});

    _weakMaps.KEY_TO_VALUE_ELEMENT.set(portableTextEditor.slateInstance, {});

    return () => {
      _weakMaps.KEY_TO_SLATE_ELEMENT.delete(portableTextEditor.slateInstance);

      _weakMaps.KEY_TO_VALUE_ELEMENT.delete(portableTextEditor.slateInstance);
    };
  }, [portableTextEditor.slateInstance]); // Restore value from props

  (0, _react.useEffect)(() => {
    if (isThrottling) {
      debug('Not setting value from props (throttling)');
      return;
    }

    if (isSelecting) {
      debug('Not setting value from props (is selecting)');
      return;
    }

    var fromMap = VALUE_TO_SLATE_VALUE.get(value || []);

    if (fromMap === stateValue) {
      debug('Value in sync, not updating value from props');
    } else {
      debug('Setting value from props');
      var slateValueFromProps = (0, _values.toSlateValue)(value, portableTextFeatures.types.block.name, _weakMaps.KEY_TO_SLATE_ELEMENT.get(portableTextEditor.slateInstance));
      setStateValue(slateValueFromProps);
      stateValueRef.current = slateValueFromProps;
      VALUE_TO_SLATE_VALUE.set(value || [], slateValueFromProps);
      change$.next({
        type: 'value',
        value
      });
    }
  }, [value, isSelecting, isThrottling, portableTextEditor.slateInstance]); // Restore selection from props

  (0, _react.useEffect)(() => {
    if (propsSelection && !isThrottling && !(0, _isEqual2.default)(propsSelection, (0, _ranges.toPortableTextRange)(portableTextEditor.slateInstance))) {
      debug('Selection from props', propsSelection);
      var normalizedSelection = (0, _selection2.normalizeSelection)(propsSelection, value);

      if (normalizedSelection !== null) {
        debug('Normalized selection from props', normalizedSelection);
        var slateRange = (0, _ranges.toSlateRange)(normalizedSelection, portableTextEditor.slateInstance);
        setSelection(slateRange);
        selectionRef.current = slateRange;
      } else if (stateValue) {
        debug('Selecting top document');
        setSelection(SELECT_TOP_DOCUMENT);
        selectionRef.current = SELECT_TOP_DOCUMENT;
      }
    }
  }, [propsSelection]); // Set initial selection from props

  (0, _react.useEffect)(() => {
    if (propsSelection) {
      _PortableTextEditor.PortableTextEditor.select(portableTextEditor, propsSelection);
    }
  }, []); // Handle copy in the editor

  var handleCopy = (0, _react.useCallback)(event => {
    if (onCopy) {
      var result = onCopy(event); // CopyFn may return something to avoid doing default stuff

      if (result !== undefined) {
        event.preventDefault();
        return;
      }
    }

    if ((0, _copyPaste.hasEditableTarget)(portableTextEditor.slateInstance, event.target)) {
      // Set Portable Text on the clipboard
      (0, _copyPaste.setFragmentData)(event.clipboardData, portableTextEditor.slateInstance, portableTextFeatures);
    }
  }, [onCopy, portableTextEditor.slateInstance, portableTextFeatures]); // Handle pasting in the editor

  var handlePaste = (0, _react.useCallback)(event => {
    event.persist(); // Keep the event through the plugin chain after calling next()

    var _selection = _PortableTextEditor.PortableTextEditor.getSelection(portableTextEditor);

    var type = portableTextFeatures.types.portableText;

    if (!_selection) {
      return;
    }

    if (onPaste) {
      var resolveOnPasteResultOrError = () => {
        try {
          return onPaste({
            event,
            value,
            path: _selection.focus.path,
            type
          });
        } catch (error) {
          return error;
        }
      }; // Resolve it as promise (can be either async promise or sync return value)


      var resolved = Promise.resolve(resolveOnPasteResultOrError());
      resolved.then(result => {
        debug('Custom paste function from client resolved', result);
        change$.next({
          type: 'loading',
          isLoading: true
        });

        if (!result) {
          return;
        }

        if (result instanceof Error) {
          throw result;
        }

        if (result && result.insert) {
          event.preventDefault(); // Stop the chain

          var allowedDecorators = portableTextFeatures.decorators.map(item => item.value);
          var blocksToInsertNormalized = result.insert.map(block => (0, _blockTools.normalizeBlock)(block, {
            allowedDecorators
          }));
          var dataTransfer = new DataTransfer();
          var stringToEncode = JSON.stringify((0, _values.toSlateValue)(blocksToInsertNormalized, portableTextFeatures.types.block.name));
          var encoded = window.btoa(encodeURIComponent(stringToEncode));
          dataTransfer.setData('application/x-slate-fragment', encoded);
          portableTextEditor.slateInstance.insertData(dataTransfer);
          change$.next({
            type: 'loading',
            isLoading: false
          });
          portableTextEditor.slateInstance.onChange();
          return;
        }

        console.warn('Your onPaste function returned something unexpected:', result);
      }).catch(error => {
        change$.next({
          type: 'loading',
          isLoading: false
        });
        console.error(error); // eslint-disable-line no-console

        return error;
      });
    }
  }, [change$, onPaste, portableTextEditor.slateInstance, portableTextFeatures, value]); // There's a bug in Slate atm regarding void nodes not being deleted. Seems related
  // to 'hanging: true' and 'voids: false'. 2020/05/26

  var handleCut = (0, _react.useCallback)(event => {
    event.preventDefault();
    event.stopPropagation();

    if (portableTextEditor.slateInstance.selection) {
      _slateReact.ReactEditor.setFragmentData(portableTextEditor.slateInstance, event.clipboardData);

      _slate.Transforms.delete(portableTextEditor.slateInstance, {
        at: portableTextEditor.slateInstance.selection,
        voids: false,
        hanging: true
      });

      _slate.Transforms.collapse(portableTextEditor.slateInstance);

      portableTextEditor.slateInstance.onChange();
    }

    return portableTextEditor.slateInstance;
  }, [portableTextEditor.slateInstance]); // Emit selection after a selection is made

  var emitSelection = (0, _react.useCallback)(() => {
    try {
      var newSelection = (0, _ranges.toPortableTextRange)(portableTextEditor.slateInstance); // debug('Emitting new selection', JSON.stringify(newSelection))

      change$.next({
        type: 'selection',
        selection: newSelection
      });
    } catch (err) {
      change$.next({
        type: 'selection',
        selection: null
      });
    }
  }, [change$, portableTextEditor]);
  var handleSelect = (0, _react.useCallback)(() => {
    if (isThrottling) {
      return;
    }

    emitSelection();
  }, [emitSelection, isThrottling]);
  (0, _react.useEffect)(() => {
    if (isThrottling) {
      return;
    }

    emitSelection();
  }, [emitSelection, isThrottling]);
  (0, _react.useEffect)(() => {
    emitSelection();
  }, [emitSelection, selection]); // Make sure that when the user is actively selecting something, we don't update the editor or selections will be broken

  var _isSelecting = (0, _react.useRef)(false);

  var onSelectStart = (0, _react.useCallback)(event => {
    if (_slateReact.ReactEditor.hasDOMNode(portableTextEditor.slateInstance, event.target)) {
      debug('Start selecting');
      _isSelecting.current = true;
      setTimeout(() => setIsSelecting(true));
    }
  }, [portableTextEditor]);
  var onSelectEnd = (0, _react.useCallback)(() => {
    if (_isSelecting.current) {
      debug('Done selecting');
      setTimeout(() => setIsSelecting(false));
    }
  }, [_isSelecting]);

  var isSelectKeys = event => (0, _isHotkey.default)('shift+down', event) || (0, _isHotkey.default)('shift+up', event) || (0, _isHotkey.default)('shift+left', event) || (0, _isHotkey.default)('shift+right', event) || (0, _isHotkey.default)('shift+end', event) || (0, _isHotkey.default)('shift+home', event) || (0, _isHotkey.default)('shift+pageDown', event) || (0, _isHotkey.default)('shift+pageUp', event);

  var isSelectingWithKeys = (0, _react.useRef)(false);
  var onSelectStartWithKeys = (0, _react.useCallback)(event => {
    if (isSelectKeys(event)) {
      isSelectingWithKeys.current = true;
      onSelectStart(event);
    }
  }, [onSelectStart]);
  var onSelectEndWithKeys = (0, _react.useCallback)(event => {
    if (isSelectingWithKeys.current && event.key === 'Shift') {
      onSelectEnd();
      isSelectingWithKeys.current = false;
    }
  }, [onSelectEnd]);
  (0, _react.useEffect)(() => {
    if (ref.current) {
      var currentRef = ref.current;
      currentRef.addEventListener('keydown', onSelectStartWithKeys, false);
      currentRef.addEventListener('keyup', onSelectEndWithKeys, false);
      currentRef.addEventListener('mousedown', onSelectStart, false);
      currentRef.addEventListener('mouseup', onSelectEnd, false);
      currentRef.addEventListener('dragend', onSelectEnd, false);
      return () => {
        currentRef.removeEventListener('keydown', onSelectStartWithKeys, false);
        currentRef.removeEventListener('keyup', onSelectEndWithKeys, false);
        currentRef.removeEventListener('mousedown', onSelectStart, false);
        currentRef.removeEventListener('mouseup', onSelectEnd, false);
        currentRef.removeEventListener('dragend', onSelectEnd, false);
      };
    }

    return NOOP;
  }, [ref, onSelectEnd, onSelectEndWithKeys, onSelectStart, onSelectStartWithKeys]);
  var handleOnFocus = (0, _react.useCallback)(() => {
    change$.next({
      type: 'focus'
    });
  }, [change$]);
  var handleOnBlur = (0, _react.useCallback)(() => {
    change$.next({
      type: 'blur'
    });
  }, [change$]);
  var handleOnBeforeInput = (0, _react.useCallback)(event => {
    if (onBeforeInput) {
      onBeforeInput(event);
    }
  }, [onBeforeInput]);
  var handleKeyDown = portableTextEditor.slateInstance.pteWithHotKeys;
  var scrollSelectionIntoViewToSlate = (0, _react.useMemo)(() => {
    // Use slate-react default scroll into view
    if (scrollSelectionIntoView === undefined) {
      return undefined;
    } // Disable scroll into view totally


    if (scrollSelectionIntoView === null) {
      return NOOP;
    } // Translate PortableTextEditor prop fn to Slate plugin fn


    return (editor, domRange) => {
      scrollSelectionIntoView(portableTextEditor, domRange);
    };
  }, [portableTextEditor, scrollSelectionIntoView]); // The editor

  var slateEditable = (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement(_slateReact.Slate, {
    onChange: handleChange,
    editor: portableTextEditor.slateInstance,
    selection: selection,
    value: getValueOrIntitialValue(stateValue, [placeHolderBlock])
  }, /*#__PURE__*/_react.default.createElement(_slateReact.Editable, {
    autoFocus: false,
    className: "pt-editable",
    onBlur: handleOnBlur,
    onCopy: handleCopy,
    onCut: handleCut,
    onDOMBeforeInput: handleOnBeforeInput,
    onFocus: handleOnFocus,
    onKeyDown: handleKeyDown,
    onPaste: handlePaste,
    onSelect: handleSelect,
    placeholder: placeholderText,
    readOnly: readOnly,
    renderElement: renderElement,
    renderLeaf: renderLeaf,
    scrollSelectionIntoView: scrollSelectionIntoViewToSlate,
    spellCheck: spellCheck
  })), [handleChange, handleCopy, handleCut, handleKeyDown, handleOnBeforeInput, handleOnBlur, handleOnFocus, handlePaste, handleSelect, placeHolderBlock, placeholderText, portableTextEditor.slateInstance, readOnly, renderElement, renderLeaf, scrollSelectionIntoViewToSlate, selection, spellCheck, stateValue]);

  if (!portableTextEditor) {
    return null;
  }

  return /*#__PURE__*/_react.default.createElement("div", _extends({
    ref: ref
  }, restProps), slateEditable);
});
exports.PortableTextEditable = PortableTextEditable;

function getValueOrIntitialValue(value, initialValue) {
  if (Array.isArray(value) && value.length > 0) {
    return value;
  }

  return initialValue;
}